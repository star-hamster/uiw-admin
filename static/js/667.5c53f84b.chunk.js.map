{"version":3,"file":"static/js/667.5c53f84b.chunk.js","mappings":"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","sources":["../../../node_modules/@tanstack/query-core/src/utils.ts","../../../node_modules/@babel/runtime/helpers/esm/get.js","../../../node_modules/@babel/runtime/helpers/esm/superPropBase.js","../../../node_modules/@tanstack/query-core/src/logger.ts","../../../node_modules/@tanstack/query-core/src/notifyManager.ts","../../../node_modules/@tanstack/query-core/src/subscribable.ts","../../../node_modules/@tanstack/query-core/src/focusManager.ts","../../../node_modules/@tanstack/query-core/src/onlineManager.ts","../../../node_modules/@tanstack/query-core/src/retryer.ts","../../../node_modules/@tanstack/query-core/src/removable.ts","../../../node_modules/@tanstack/query-core/src/query.ts","../../../node_modules/@tanstack/query-core/src/queryCache.ts","../../../node_modules/@tanstack/query-core/src/mutation.ts","../../../node_modules/@tanstack/query-core/src/mutationCache.ts","../../../node_modules/@tanstack/query-core/src/infiniteQueryBehavior.ts","../../../node_modules/@tanstack/query-core/src/queryClient.ts","../../../node_modules/@tanstack/react-query/src/useSyncExternalStore.ts","../../../node_modules/@tanstack/query-core/src/mutationObserver.ts","../../../node_modules/@tanstack/react-query/src/QueryClientProvider.tsx","../../../node_modules/@tanstack/react-query/src/useMutation.ts","../../../node_modules/@tanstack/react-query/src/utils.ts","../../../node_modules/@kkt/request/esm/fetch.js","../../../node_modules/@kkt/request/esm/index.js","../../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js","../../../node_modules/use-sync-external-store/shim/index.js"],"sourcesContent":["import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationFunction,\n  MutationKey,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Include or exclude fetching mutations\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in window\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter((x) => array2.indexOf(x) === -1)\n}\n\nexport function replaceAt<T>(array: T[], index: number, value: T): T[] {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<\n  TOptions extends QueryOptions<any, any, any, TQueryKey>,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | TOptions,\n  arg2?: QueryFunction<any, TQueryKey> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return { ...arg2, queryKey: arg1 } as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>,\n>(\n  arg1: MutationKey | MutationFunction<any, any> | TOptions,\n  arg2?: MutationFunction<any, any> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3, mutationKey: arg1, mutationFn: arg2 } as TOptions\n    }\n    return { ...arg2, mutationKey: arg1 } as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2, mutationFn: arg1 } as TOptions\n  }\n\n  return { ...arg1 } as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1) ? [{ ...arg2, queryKey: arg1 }, arg3] : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function parseMutationFilterArgs<\n  TFilters extends MutationFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1)\n      ? [{ ...arg2, mutationKey: arg1 }, arg3]\n      : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (\n    typeof fetchStatus !== 'undefined' &&\n    fetchStatus !== query.state.fetchStatus\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, fetching, predicate, mutationKey } = filters\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (\n        hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)\n      ) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (\n    typeof fetching === 'boolean' &&\n    (mutation.state.status === 'loading') !== fetching\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: QueryOptions<any, any, any, TQueryKey>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashQueryKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean {\n  return partialDeepEqual(a, b)\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: unknown): value is QueryKey {\n  return Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void) {\n  sleep(0).then(callback)\n}\n\nexport function getAbortController(): AbortController | undefined {\n  if (typeof AbortController === 'function') {\n    return new AbortController()\n  }\n  return\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual?.(prevData, data)) {\n    return prevData as TData\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data)\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n","import superPropBase from \"./superPropBase.js\";\nexport default function _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}","export interface Logger {\n  log: LogFunction\n  warn: LogFunction\n  error: LogFunction\n}\n\ntype LogFunction = (...args: any[]) => void\n\nexport const defaultLogger: Logger = console\n","import { scheduleMicrotask } from './utils'\n\n// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\nexport function createNotifyManager() {\n  let queue: NotifyCallback[] = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n\n  const batch = <T>(callback: () => T): T => {\n    let result\n    transactions++\n    try {\n      result = callback()\n    } finally {\n      transactions--\n      if (!transactions) {\n        flush()\n      }\n    }\n    return result\n  }\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  const batchCalls = <T extends Function>(callback: T): T => {\n    return ((...args: any[]) => {\n      schedule(() => {\n        callback(...args)\n      })\n    }) as any\n  }\n\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  const setNotifyFunction = (fn: NotifyFunction) => {\n    notifyFn = fn\n  }\n\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  const setBatchNotifyFunction = (fn: BatchNotifyFunction) => {\n    batchNotifyFn = fn\n  }\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction,\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n","type Listener = () => void\n\nexport class Subscribable<TListener extends Function = Listener> {\n  protected listeners: TListener[]\n\n  constructor() {\n    this.listeners = []\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    this.listeners.push(listener as TListener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners = this.listeners.filter((x) => x !== listener)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.length > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable {\n  private focused?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibillitychange and focus\n        window.addEventListener('visibilitychange', listener, false)\n        window.addEventListener('focus', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n          window.removeEventListener('focus', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    this.focused = focused\n\n    if (focused) {\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    this.listeners.forEach((listener) => {\n      listener()\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.focused === 'boolean') {\n      return this.focused\n    }\n\n    // document global can be unavailable in react native\n    if (typeof document === 'undefined') {\n      return true\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(\n      document.visibilityState,\n    )\n  }\n}\n\nexport const focusManager = new FocusManager()\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setOnline: (online?: boolean) => void,\n) => (() => void) | undefined\n\nexport class OnlineManager extends Subscribable {\n  private online?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline()\n        // Listen to online\n        window.addEventListener('online', listener, false)\n        window.addEventListener('offline', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', listener)\n          window.removeEventListener('offline', listener)\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((online?: boolean) => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online)\n      } else {\n        this.onOnline()\n      }\n    })\n  }\n\n  setOnline(online?: boolean): void {\n    this.online = online\n\n    if (online) {\n      this.onOnline()\n    }\n  }\n\n  onOnline(): void {\n    this.listeners.forEach((listener) => {\n      listener()\n    })\n  }\n\n  isOnline(): boolean {\n    if (typeof this.online === 'boolean') {\n      return this.online\n    }\n\n    if (\n      typeof navigator === 'undefined' ||\n      typeof navigator.onLine === 'undefined'\n    ) {\n      return true\n    }\n\n    return navigator.onLine\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n","import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { sleep } from './utils'\nimport type { CancelOptions, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = unknown> {\n  fn: () => TData | Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = unknown> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = unknown>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => boolean) | undefined\n  let promiseResolve: (data: TData) => void\n  let promiseReject: (error: TError) => void\n\n  const promise = new Promise<TData>((outerResolve, outerReject) => {\n    promiseResolve = outerResolve\n    promiseReject = outerReject\n  })\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const shouldPause = () =>\n    !focusManager.isFocused() ||\n    (config.networkMode !== 'always' && !onlineManager.isOnline())\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      promiseResolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      promiseReject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        const canContinue = isResolved || !shouldPause()\n        if (canContinue) {\n          continueResolve(value)\n        }\n        return canContinue\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // Execute query\n    try {\n      promiseOrValue = config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? 3\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            if (shouldPause()) {\n              return pause()\n            }\n            return\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  // Start loop\n  if (canFetch(config.networkMode)) {\n    run()\n  } else {\n    pause().then(run)\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn?.()\n      return didContinue ? promise : Promise.resolve()\n    },\n    cancelRetry,\n    continueRetry,\n  }\n}\n","import { isServer, isValidTimeout } from './utils'\n\nexport abstract class Removable {\n  cacheTime!: number\n  private gcTimeout?: ReturnType<typeof setTimeout>\n\n  destroy(): void {\n    this.clearGcTimeout()\n  }\n\n  protected scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.cacheTime)\n    }\n  }\n\n  protected updateCacheTime(newCacheTime: number | undefined): void {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(\n      this.cacheTime || 0,\n      newCacheTime ?? (isServer ? Infinity : 5 * 60 * 1000),\n    )\n  }\n\n  protected clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout)\n      this.gcTimeout = undefined\n    }\n  }\n\n  protected abstract optionalRemove(): void\n}\n","import { getAbortController, noop, replaceData, timeUntilStale } from './utils'\nimport type {\n  InitialDataFunction,\n  QueryKey,\n  QueryOptions,\n  QueryStatus,\n  QueryFunctionContext,\n  QueryMeta,\n  CancelOptions,\n  SetDataOptions,\n  FetchStatus,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport type { Logger } from './logger'\nimport { defaultLogger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport type { Retryer } from './retryer'\nimport { isCancelledError, canFetch, createRetryer } from './retryer'\nimport { Removable } from './removable'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  cache: QueryCache\n  queryKey: TQueryKey\n  queryHash: string\n  logger?: Logger\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = unknown> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: any\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal?: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n  ) => void\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: any\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: any\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  initialState: QueryState<TData, TError>\n  revertState?: QueryState<TData, TError>\n  state: QueryState<TData, TError>\n  isFetchingOptimistic?: boolean\n\n  private cache: QueryCache\n  private logger: Logger\n  private promise?: Promise<TData>\n  private retryer?: Retryer<TData>\n  private observers: QueryObserver<any, any, any, any, any>[]\n  private defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  private abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.abortSignalConsumed = false\n    this.defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.cache = config.cache\n    this.logger = config.logger || defaultLogger\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.initialState = config.state || getDefaultState(this.options)\n    this.state = this.initialState\n    this.scheduleGc()\n  }\n\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  private setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    this.updateCacheTime(this.options.cacheTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.promise\n    this.retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some((observer) => observer.options.enabled !== false)\n  }\n\n  isDisabled(): boolean {\n    return this.getObserversCount() > 0 && !this.isActive()\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      this.observers.some((observer) => observer.getCurrentResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    if (observer) {\n      observer.refetch({ cancelRefetch: false })\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    if (observer) {\n      observer.refetch({ cancelRefetch: false })\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({ revert: true })\n          } else {\n            this.retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({ silent: true })\n      } else if (this.promise) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.retryer?.continueRetry()\n        // Return current promise if we are already fetching\n        return this.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = getAbortController()\n\n    // Create query function context\n    const queryFnContext: QueryFunctionContext<TQueryKey> = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta,\n    }\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true\n            return abortController.signal\n          }\n          return undefined\n        },\n      })\n    }\n\n    addSignalProperty(queryFnContext)\n\n    // Create fetch function\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn')\n      }\n      this.abortSignalConsumed = false\n      return this.options.queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const context: FetchContext<TQueryFnData, TError, TData, TQueryKey> = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(context)\n\n    // Store state in case the current fetch needs to be reverted\n    this.revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.cache.config.onError?.(error, this as Query<any, any, any, any>)\n        this.cache.config.onSettled?.(\n          this.state.data,\n          error,\n          this as Query<any, any, any, any>,\n        )\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error)\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      }\n      this.isFetchingOptimistic = false\n    }\n\n    // Try to fetch the data\n    this.retryer = createRetryer({\n      fn: context.fetchFn as () => TData,\n      abort: abortController?.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error('undefined') as any)\n          return\n        }\n\n        this.setData(data as TData)\n\n        // Notify cache callback\n        this.cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.cache.config.onSettled?.(\n          data,\n          this.state.error,\n          this as Query<any, any, any, any>,\n        )\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc()\n        }\n        this.isFetchingOptimistic = false\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n    })\n\n    this.promise = this.retryer.promise\n\n    return this.promise\n  }\n\n  private dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: action.meta ?? null,\n            fetchStatus: canFetch(this.options.networkMode)\n              ? 'fetching'\n              : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading',\n            }),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error as unknown\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState }\n          }\n\n          return {\n            ...state,\n            error: error as TError,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error as TError,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate(action)\n      })\n\n      this.cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = typeof data !== 'undefined'\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle',\n  }\n}\n","import type { QueryFilters } from './utils'\nimport { hashQueryKeyByOptions, matchQuery, parseFilterArgs } from './utils'\nimport type { Action, QueryState } from './query'\nimport { Query } from './query'\nimport type { NotifyEvent, QueryKey, QueryOptions } from './types'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (error: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: unknown | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ntype QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  config: QueryCacheConfig\n\n  private queries: Query<any, any, any, any>[]\n  private queriesMap: QueryHashMap\n\n  constructor(config?: QueryCacheConfig) {\n    super()\n    this.config = config || {}\n    this.queries = []\n    this.queriesMap = {}\n  }\n\n  build<TQueryFnData, TError, TData, TQueryKey extends QueryKey>(\n    client: QueryClient,\n    options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey!\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query\n      this.queries.push(query)\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.queriesMap[query.queryHash]\n\n    if (queryInMap) {\n      query.destroy()\n\n      this.queries = this.queries.filter((x) => x !== query)\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash]\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.queriesMap[queryHash]\n  }\n\n  getAll(): Query[] {\n    return this.queries\n  }\n\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    arg1: QueryKey,\n    arg2?: QueryFilters,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const [filters] = parseFilterArgs(arg1, arg2)\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.queries.find((query) => matchQuery(filters, query))\n  }\n\n  findAll(queryKey?: QueryKey, filters?: QueryFilters): Query[]\n  findAll(filters?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[] {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    return Object.keys(filters).length > 0\n      ? this.queries.filter((query) => matchQuery(filters, query))\n      : this.queries\n  }\n\n  notify(event: QueryCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n","import type { MutationOptions, MutationStatus, MutationMeta } from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport type { Logger } from './logger'\nimport { defaultLogger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport { Removable } from './removable'\nimport type { Retryer } from './retryer'\nimport { canFetch, createRetryer } from './retryer'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  logger?: Logger\n  defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n  meta?: MutationMeta\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  failureReason: TError | null\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError | null\n}\n\ninterface LoadingAction<TVariables, TContext> {\n  type: 'loading'\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError, TVariables, TContext> {\n  type: 'setState'\n  state: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | LoadingAction<TVariables, TContext>\n  | PauseAction\n  | SetStateAction<TData, TError, TVariables, TContext>\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> extends Removable {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options!: MutationOptions<TData, TError, TVariables, TContext>\n  mutationId: number\n\n  private observers: MutationObserver<TData, TError, TVariables, TContext>[]\n  private defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  private mutationCache: MutationCache\n  private logger: Logger\n  private retryer?: Retryer<TData>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    super()\n\n    this.defaultOptions = config.defaultOptions\n    this.mutationId = config.mutationId\n    this.mutationCache = config.mutationCache\n    this.logger = config.logger || defaultLogger\n    this.observers = []\n    this.state = config.state || getDefaultState()\n\n    this.setOptions(config.options)\n    this.scheduleGc()\n  }\n\n  setOptions(\n    options?: MutationOptions<TData, TError, TVariables, TContext>,\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    this.updateCacheTime(this.options.cacheTime)\n  }\n\n  get meta(): MutationMeta | undefined {\n    return this.options.meta\n  }\n\n  setState(state: MutationState<TData, TError, TVariables, TContext>): void {\n    this.dispatch({ type: 'setState', state })\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout()\n\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer,\n      })\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.observers = this.observers.filter((x) => x !== observer)\n\n    this.scheduleGc()\n\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer,\n    })\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc()\n      } else {\n        this.mutationCache.remove(this)\n      }\n    }\n  }\n\n  continue(): Promise<unknown> {\n    return this.retryer?.continue() ?? this.execute()\n  }\n\n  async execute(): Promise<TData> {\n    const executeMutation = () => {\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found')\n          }\n          return this.options.mutationFn(this.state.variables!)\n        },\n        onFail: (failureCount, error) => {\n          this.dispatch({ type: 'failed', failureCount, error })\n        },\n        onPause: () => {\n          this.dispatch({ type: 'pause' })\n        },\n        onContinue: () => {\n          this.dispatch({ type: 'continue' })\n        },\n        retry: this.options.retry ?? 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode,\n      })\n\n      return this.retryer.promise\n    }\n\n    const restored = this.state.status === 'loading'\n    try {\n      if (!restored) {\n        this.dispatch({ type: 'loading', variables: this.options.variables! })\n        // Notify cache callback\n        await this.mutationCache.config.onMutate?.(\n          this.state.variables,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n        const context = await this.options.onMutate?.(this.state.variables!)\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables,\n          })\n        }\n      }\n      const data = await executeMutation()\n\n      // Notify cache callback\n      await this.mutationCache.config.onSuccess?.(\n        data,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSuccess?.(\n        data,\n        this.state.variables!,\n        this.state.context!,\n      )\n\n      // Notify cache callback\n      await this.mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSettled?.(\n        data,\n        null,\n        this.state.variables!,\n        this.state.context,\n      )\n\n      this.dispatch({ type: 'success', data })\n      return data\n    } catch (error) {\n      try {\n        // Notify cache callback\n        await this.mutationCache.config.onError?.(\n          error,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error)\n        }\n\n        await this.options.onError?.(\n          error as TError,\n          this.state.variables!,\n          this.state.context,\n        )\n\n        // Notify cache callback\n        await this.mutationCache.config.onSettled?.(\n          undefined,\n          error,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onSettled?.(\n          undefined,\n          error as TError,\n          this.state.variables!,\n          this.state.context,\n        )\n        throw error\n      } finally {\n        this.dispatch({ type: 'error', error: error as TError })\n      }\n    }\n  }\n\n  private dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    const reducer = (\n      state: MutationState<TData, TError, TVariables, TContext>,\n    ): MutationState<TData, TError, TVariables, TContext> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true,\n          }\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false,\n          }\n        case 'loading':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables,\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false,\n          }\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error',\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onMutationUpdate(action)\n      })\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action,\n      })\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n  }\n}\n","import type { MutationObserver } from './mutationObserver'\nimport type { MutationOptions, NotifyEvent } from './types'\nimport type { QueryClient } from './queryClient'\nimport { notifyManager } from './notifyManager'\nimport type { Action, MutationState } from './mutation'\nimport { Mutation } from './mutation'\nimport type { MutationFilters } from './utils'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: unknown | null,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\ntype MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  config: MutationCacheConfig\n\n  private mutations: Mutation<any, any, any, any>[]\n  private mutationId: number\n  private resuming: Promise<unknown> | undefined\n\n  constructor(config?: MutationCacheConfig) {\n    super()\n    this.config = config || {}\n    this.mutations = []\n    this.mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey\n        ? client.getMutationDefaults(options.mutationKey)\n        : undefined,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.mutations.push(mutation)\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    this.mutations = this.mutations.filter((x) => x !== mutation)\n    this.notify({ type: 'removed', mutation })\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.mutations.forEach((mutation) => {\n        this.remove(mutation)\n      })\n    })\n  }\n\n  getAll(): Mutation[] {\n    return this.mutations\n  }\n\n  find<TData = unknown, TError = unknown, TVariables = any, TContext = unknown>(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.mutations.find((mutation) => matchMutation(filters, mutation))\n  }\n\n  findAll(filters: MutationFilters): Mutation[] {\n    return this.mutations.filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    this.resuming = (this.resuming ?? Promise.resolve())\n      .then(() => {\n        const pausedMutations = this.mutations.filter((x) => x.state.isPaused)\n        return notifyManager.batch(() =>\n          pausedMutations.reduce(\n            (promise, mutation) =>\n              promise.then(() => mutation.continue().catch(noop)),\n            Promise.resolve() as Promise<unknown>,\n          ),\n        )\n      })\n      .then(() => {\n        this.resuming = undefined\n      })\n\n    return this.resuming\n  }\n}\n","import type { QueryBehavior } from './query'\n\nimport type {\n  InfiniteData,\n  QueryFunctionContext,\n  QueryOptions,\n  RefetchQueryFilters,\n} from './types'\n\nexport function infiniteQueryBehavior<\n  TQueryFnData,\n  TError,\n  TData,\n>(): QueryBehavior<TQueryFnData, TError, InfiniteData<TData>> {\n  return {\n    onFetch: (context) => {\n      context.fetchFn = () => {\n        const refetchPage: RefetchQueryFilters['refetchPage'] | undefined =\n          context.fetchOptions?.meta?.refetchPage\n        const fetchMore = context.fetchOptions?.meta?.fetchMore\n        const pageParam = fetchMore?.pageParam\n        const isFetchingNextPage = fetchMore?.direction === 'forward'\n        const isFetchingPreviousPage = fetchMore?.direction === 'backward'\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        let newPageParams = oldPageParams\n        let cancelled = false\n\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal?.aborted) {\n                cancelled = true\n              } else {\n                context.signal?.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn || (() => Promise.reject('Missing queryFn'))\n\n        const buildNewPages = (\n          pages: unknown[],\n          param: unknown,\n          page: unknown,\n          previous?: boolean,\n        ) => {\n          newPageParams = previous\n            ? [param, ...newPageParams]\n            : [...newPageParams, param]\n          return previous ? [page, ...pages] : [...pages, page]\n        }\n\n        // Create function to fetch a page\n        const fetchPage = (\n          pages: unknown[],\n          manual?: boolean,\n          param?: unknown,\n          previous?: boolean,\n        ): Promise<unknown[]> => {\n          if (cancelled) {\n            return Promise.reject('Cancelled')\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages)\n          }\n\n          const queryFnContext: QueryFunctionContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const queryFnResult = queryFn(queryFnContext)\n\n          const promise = Promise.resolve(queryFnResult).then((page) =>\n            buildNewPages(pages, param, page, previous),\n          )\n\n          return promise\n        }\n\n        let promise: Promise<unknown[]>\n\n        // Fetch first page?\n        if (!oldPages.length) {\n          promise = fetchPage([])\n        }\n\n        // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getNextPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param)\n        }\n\n        // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getPreviousPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param, true)\n        }\n\n        // Refetch pages\n        else {\n          newPageParams = []\n\n          const manual = typeof context.options.getNextPageParam === 'undefined'\n\n          const shouldFetchFirstPage =\n            refetchPage && oldPages[0]\n              ? refetchPage(oldPages[0], 0, oldPages)\n              : true\n\n          // Fetch first page\n          promise = shouldFetchFirstPage\n            ? fetchPage([], manual, oldPageParams[0])\n            : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]))\n\n          // Fetch remaining pages\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then((pages) => {\n              const shouldFetchNextPage =\n                refetchPage && oldPages[i]\n                  ? refetchPage(oldPages[i], i, oldPages)\n                  : true\n\n              if (shouldFetchNextPage) {\n                const param = manual\n                  ? oldPageParams[i]\n                  : getNextPageParam(context.options, pages)\n                return fetchPage(pages, manual, param)\n              }\n              return Promise.resolve(\n                buildNewPages(pages, oldPageParams[i], oldPages[i]),\n              )\n            })\n          }\n        }\n\n        const finalPromise = promise.then((pages) => ({\n          pages,\n          pageParams: newPageParams,\n        }))\n\n        return finalPromise\n      }\n    },\n  }\n}\n\nexport function getNextPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getNextPageParam?.(pages[pages.length - 1], pages)\n}\n\nexport function getPreviousPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getPreviousPageParam?.(pages[0], pages)\n}\n\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasNextPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages)\n    return (\n      typeof nextPageParam !== 'undefined' &&\n      nextPageParam !== null &&\n      nextPageParam !== false\n    )\n  }\n  return\n}\n\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasPreviousPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages)\n    return (\n      typeof previousPageParam !== 'undefined' &&\n      previousPageParam !== null &&\n      previousPageParam !== false\n    )\n  }\n  return\n}\n","import type { QueryFilters, Updater, MutationFilters } from './utils'\nimport {\n  hashQueryKey,\n  noop,\n  parseFilterArgs,\n  parseQueryArgs,\n  partialMatchKey,\n  hashQueryKeyByOptions,\n  functionalUpdate,\n} from './utils'\nimport type {\n  QueryClientConfig,\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  ResetQueryFilters,\n  SetDataOptions,\n  WithRequired,\n} from './types'\nimport type { QueryState } from './query'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type { CancelOptions, DefaultedQueryObserverOptions } from './types'\nimport type { Logger } from './logger'\nimport { defaultLogger } from './logger'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: QueryOptions<any, any, any>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  private queryCache: QueryCache\n  private mutationCache: MutationCache\n  private logger: Logger\n  private defaultOptions: DefaultOptions\n  private queryDefaults: QueryDefaults[]\n  private mutationDefaults: MutationDefaults[]\n  private mountCount: number\n  private unsubscribeFocus?: () => void\n  private unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.queryCache = config.queryCache || new QueryCache()\n    this.mutationCache = config.mutationCache || new MutationCache()\n    this.logger = config.logger || defaultLogger\n    this.defaultOptions = config.defaultOptions || {}\n    this.queryDefaults = []\n    this.mutationDefaults = []\n    this.mountCount = 0\n\n    if (process.env.NODE_ENV !== 'production' && config.logger) {\n      this.logger.error(\n        `Passing a custom logger has been deprecated and will be removed in the next major version.`,\n      )\n    }\n  }\n\n  mount(): void {\n    this.mountCount++\n    if (this.mountCount !== 1) return\n\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations()\n        this.queryCache.onFocus()\n      }\n    })\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations()\n        this.queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.mountCount--\n    if (this.mountCount !== 0) return\n\n    this.unsubscribeFocus?.()\n    this.unsubscribeFocus = undefined\n\n    this.unsubscribeOnline?.()\n    this.unsubscribeOnline = undefined\n  }\n\n  isFetching(filters?: QueryFilters): number\n  isFetching(queryKey?: QueryKey, filters?: QueryFilters): number\n  isFetching(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): number {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    filters.fetchStatus = 'fetching'\n    return this.queryCache.findAll(filters).length\n  }\n\n  isMutating(filters?: MutationFilters): number {\n    return this.mutationCache.findAll({ ...filters, fetching: true }).length\n  }\n\n  getQueryData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n    filters?: QueryFilters,\n  ): TQueryFnData | undefined {\n    return this.queryCache.find<TQueryFnData>(queryKey, filters)?.state.data\n  }\n\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: WithRequired<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: Omit<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: Omit<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey' | 'queryFn'\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | WithRequired<\n          FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n          'queryKey'\n        >,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const cachedData = this.getQueryData<TData>(parsedOptions.queryKey!)\n\n    return cachedData\n      ? Promise.resolve(cachedData)\n      : this.fetchQuery(parsedOptions)\n  }\n\n  getQueriesData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n  ): [QueryKey, TQueryFnData | undefined][]\n  getQueriesData<TQueryFnData = unknown>(\n    filters: QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][]\n  getQueriesData<TQueryFnData = unknown>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return this.getQueryCache()\n      .findAll(queryKeyOrFilters)\n      .map(({ queryKey, state }) => {\n        const data = state.data as TQueryFnData | undefined\n        return [queryKey, data]\n      })\n  }\n\n  setQueryData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): TQueryFnData | undefined {\n    const query = this.queryCache.find<TQueryFnData>(queryKey)\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (typeof data === 'undefined') {\n      return undefined\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n    return this.queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n\n  setQueriesData<TQueryFnData>(\n    filters: QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n\n  setQueriesData<TQueryFnData>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return notifyManager.batch(() =>\n      this.getQueryCache()\n        .findAll(queryKeyOrFilters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<TQueryFnData = unknown, TError = undefined>(\n    queryKey: QueryKey,\n    filters?: QueryFilters,\n  ): QueryState<TQueryFnData, TError> | undefined {\n    return this.queryCache.find<TQueryFnData, TError>(queryKey, filters)?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void\n  removeQueries(queryKey?: QueryKey, filters?: QueryFilters): void\n  removeQueries(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): void {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    const queryCache = this.queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TPageData = unknown>(\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  resetQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  resetQueries(\n    arg1?: QueryKey | ResetQueryFilters,\n    arg2?: ResetQueryFilters | ResetOptions,\n    arg3?: ResetOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n    const queryCache = this.queryCache\n\n    const refetchFilters: RefetchQueryFilters = {\n      type: 'active',\n      ...filters,\n    }\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  cancelQueries(filters?: QueryFilters, options?: CancelOptions): Promise<void>\n  cancelQueries(\n    queryKey?: QueryKey,\n    filters?: QueryFilters,\n    options?: CancelOptions,\n  ): Promise<void>\n  cancelQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: QueryFilters | CancelOptions,\n    arg3?: CancelOptions,\n  ): Promise<void> {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3)\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true\n    }\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(cancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TPageData = unknown>(\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  invalidateQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  invalidateQueries(\n    arg1?: QueryKey | InvalidateQueryFilters,\n    arg2?: InvalidateQueryFilters | InvalidateOptions,\n    arg3?: InvalidateOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    return notifyManager.batch(() => {\n      this.queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      const refetchFilters: RefetchQueryFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? 'active',\n      }\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  refetchQueries<TPageData = unknown>(\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  refetchQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  refetchQueries(\n    arg1?: QueryKey | RefetchQueryFilters,\n    arg2?: RefetchQueryFilters | RefetchOptions,\n    arg3?: RefetchOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled())\n        .map((query) =>\n          query.fetch(undefined, {\n            ...options,\n            cancelRefetch: options?.cancelRefetch ?? true,\n            meta: { refetchPage: filters.refetchPage },\n          }),\n        ),\n    )\n\n    let promise = Promise.all(promises).then(noop)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(defaultedOptions.staleTime)\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    parsedOptions.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData\n    >()\n    return this.fetchQuery(parsedOptions)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    return this.mutationCache.resumePausedMutations()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.mutationCache\n  }\n\n  getLogger(): Logger {\n    return this.logger\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.defaultOptions = options\n  }\n\n  setQueryDefaults(\n    queryKey: QueryKey,\n    options: QueryObserverOptions<unknown, any, any, any>,\n  ): void {\n    const result = this.queryDefaults.find(\n      (x) => hashQueryKey(queryKey) === hashQueryKey(x.queryKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.queryDefaults.push({ queryKey, defaultOptions: options })\n    }\n  }\n\n  getQueryDefaults(\n    queryKey?: QueryKey,\n  ): QueryObserverOptions<any, any, any, any, any> | undefined {\n    if (!queryKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.queryDefaults.find((x) =>\n      partialMatchKey(queryKey, x.queryKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter((x) =>\n        partialMatchKey(queryKey, x.queryKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several query defaults match with key '${JSON.stringify(\n            queryKey,\n          )}'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  setMutationDefaults(\n    mutationKey: MutationKey,\n    options: MutationObserverOptions<any, any, any, any>,\n  ): void {\n    const result = this.mutationDefaults.find(\n      (x) => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.mutationDefaults.push({ mutationKey, defaultOptions: options })\n    }\n  }\n\n  getMutationDefaults(\n    mutationKey?: MutationKey,\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    if (!mutationKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.mutationDefaults.find((x) =>\n      partialMatchKey(mutationKey, x.mutationKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter((x) =>\n        partialMatchKey(mutationKey, x.mutationKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several mutation defaults match with key '${JSON.stringify(\n            mutationKey,\n          )}'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  defaultQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey extends QueryKey,\n  >(\n    options?:\n      | QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options?._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options?.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options?.mutationKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.queryCache.clear()\n    this.mutationCache.clear()\n  }\n}\n","'use client'\n// Temporary workaround due to an issue with react-native uSES - https://github.com/TanStack/query/pull/3601\nimport { useSyncExternalStore as uSES } from 'use-sync-external-store/shim/index.js'\n\nexport const useSyncExternalStore = uSES\n","import type { Action, Mutation } from './mutation'\nimport { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type {\n  MutateOptions,\n  MutationObserverBaseResult,\n  MutationObserverResult,\n  MutationObserverOptions,\n} from './types'\nimport { shallowEqualObjects } from './utils'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\ninterface NotifyOptions {\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  private client: QueryClient\n  private currentResult!: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n  private currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  private mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options?: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options\n    this.options = this.client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this,\n      })\n    }\n    this.currentMutation?.setOptions(this.options)\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.updateResult()\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {\n      listeners: true,\n    }\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.currentResult\n  }\n\n  reset(): void {\n    this.currentMutation = undefined\n    this.updateResult()\n    this.notify({ listeners: true })\n  }\n\n  mutate(\n    variables?: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.mutateOptions = options\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this)\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, {\n      ...this.options,\n      variables:\n        typeof variables !== 'undefined' ? variables : this.options.variables,\n    })\n\n    this.currentMutation.addObserver(this)\n\n    return this.currentMutation.execute()\n  }\n\n  private updateResult(): void {\n    const state = this.currentMutation\n      ? this.currentMutation.state\n      : getDefaultState<TData, TError, TVariables, TContext>()\n\n    const result: MutationObserverBaseResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    > = {\n      ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    }\n\n    this.currentResult = result as MutationObserverResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    >\n  }\n\n  private notify(options: NotifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions && this.hasListeners()) {\n        if (options.onSuccess) {\n          this.mutateOptions.onSuccess?.(\n            this.currentResult.data!,\n            this.currentResult.variables!,\n            this.currentResult.context!,\n          )\n          this.mutateOptions.onSettled?.(\n            this.currentResult.data!,\n            null,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        } else if (options.onError) {\n          this.mutateOptions.onError?.(\n            this.currentResult.error!,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n          this.mutateOptions.onSettled?.(\n            undefined,\n            this.currentResult.error,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      if (options.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.currentResult)\n        })\n      }\n    })\n  }\n}\n","'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\nimport type { ContextOptions } from './types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean,\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext)),\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  if (process.env.NODE_ENV !== 'production' && contextSharing) {\n    client\n      .getLogger()\n      .error(\n        `The contextSharing option has been deprecated and will be removed in the next major version`,\n      )\n  }\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { MutationFunction, MutationKey } from '@tanstack/query-core'\nimport {\n  notifyManager,\n  parseMutationArgs,\n  MutationObserver,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport { shouldThrowError } from './utils'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        queryClient,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.useErrorBoundary, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  _useErrorBoundary: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params)\n  }\n\n  return !!_useErrorBoundary\n}\n","import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nvar _excluded = [\"contentType\"];\nfunction getFetchOption(type, option) {\n  if (type === void 0) {\n    type = 'json';\n  }\n  if (option === void 0) {\n    option = {};\n  }\n  if (type === 'json') {\n    option.headers = _extends({\n      Accept: 'application/json',\n      'Content-Type': 'application/json'\n    }, option.headers);\n  } else if (type === 'form') {\n    option.headers = _extends({\n      Accept: 'application/json',\n      'Content-Type': 'application/x-www-form-urlencoded'\n    }, option.headers);\n  }\n  option.headers = new Headers(_extends({}, option.headers));\n  var token = sessionStorage.getItem('token') || localStorage.getItem('token');\n  if (token && !option.headers.get(option['headerTokenName'])) {\n    option.headers.set(option['headerTokenName'], token);\n  }\n  return _extends({}, option);\n}\n\n/**\n * Fetch API 请求\n * ## 返回状态\n *\n * 200: '服务器成功返回请求的数据'\n * 201: '新建或修改数据成功'\n * 400: '发出的请求错误'\n * 401: '用户没有权限'\n * 403: '用户访问被禁止'\n * 404: '请求不存在，服务器没有进行操作'\n * 406: '请求的格式错误'\n * 410: '资源被永久删除'\n * 422: '验证错误'\n * 500: '服务器发生错误，请检查服务器'\n * 502: '网关错误'\n * 503: '服务不可用，服务器暂时过载或维护'\n * 504: '网关超时'\n * @param url string  请求 API\n */\nexport var fetchFn = function fetchFn(url, _temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    {\n      contentType = 'json'\n    } = _ref,\n    fetchOption = _objectWithoutPropertiesLoose(_ref, _excluded);\n  return fetch(url, getFetchOption(contentType, fetchOption)).then(res => {\n    if (!/(200|201)/.test(String(res.status))) {\n      throw new Response('', {\n        status: res.status,\n        headers: res.headers,\n        statusText: res.statusText + \" - \" + (res.url || '')\n      });\n    }\n    return res.json();\n  }).catch(err => {\n    throw new Response('', {\n      status: 500,\n      statusText: err.message + \" - \" + (url || '')\n    });\n  });\n};","import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nvar _excluded = [\"url\", \"cache\", \"credentials\", \"headers\", \"integrity\", \"keepalive\", \"method\", \"mode\", \"redirect\", \"referrer\", \"referrerPolicy\", \"signal\", \"window\", \"contentType\", \"headerTokenName\"],\n  _excluded2 = [\"url\", \"cache\", \"credentials\", \"headers\", \"integrity\", \"keepalive\", \"method\", \"mode\", \"redirect\", \"referrer\", \"referrerPolicy\", \"signal\", \"window\", \"contentType\", \"headerTokenName\"];\nimport { useQuery, QueryClient, useMutation } from '@tanstack/react-query';\nimport { fetchFn } from './fetch';\nexport * from '@tanstack/react-query';\nexport * from './interface';\nexport * from './fetch';\nexport var queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      refetchOnWindowFocus: false,\n      staleTime: 10000\n    }\n  }\n});\nexport function useReactQuery(options) {\n  var _ref = options || {},\n    {\n      url = '',\n      cache,\n      credentials = 'include',\n      headers,\n      integrity,\n      keepalive,\n      method = 'GET',\n      mode,\n      redirect,\n      referrer,\n      referrerPolicy,\n      signal,\n      window,\n      contentType = 'json',\n      headerTokenName = 'x-auth'\n    } = _ref,\n    opts = _objectWithoutPropertiesLoose(_ref, _excluded);\n  var fetchOption = {\n    cache,\n    credentials,\n    headers,\n    integrity,\n    keepalive,\n    method,\n    mode,\n    redirect,\n    referrer,\n    referrerPolicy,\n    signal,\n    window\n  };\n  var queryOptions = _extends({}, opts);\n  if (url) {\n    var cusFn = () => fetchFn(url, _extends({\n      contentType\n    }, fetchOption, {\n      headerTokenName\n    }));\n    queryOptions.queryFn = queryOptions.queryFn || cusFn;\n  }\n  return useQuery(_extends({}, queryOptions));\n}\nexport function useReactMutation(options) {\n  var _ref2 = options || {},\n    {\n      url,\n      cache,\n      credentials,\n      headers,\n      integrity,\n      keepalive,\n      method = 'POST',\n      mode,\n      redirect,\n      referrer,\n      referrerPolicy,\n      signal,\n      window,\n      contentType = 'json',\n      headerTokenName = 'x-auth'\n    } = _ref2,\n    opts = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n  var fetchOption = {\n    cache,\n    credentials,\n    headers,\n    integrity,\n    keepalive,\n    method,\n    mode,\n    redirect,\n    referrer,\n    referrerPolicy,\n    signal,\n    window\n  };\n  var mutationOptions = _extends({}, opts);\n  if (url) {\n    var cusFn = newData => {\n      var body = newData;\n      if (Object.prototype.toString.call(newData).slice(8, -1) !== 'FormData') {\n        body = JSON.stringify(newData);\n      }\n      return fetchFn(url, _extends({\n        contentType\n      }, fetchOption, {\n        headerTokenName,\n        body: body\n      }));\n    };\n    mutationOptions.mutationFn = mutationOptions.mutationFn || cusFn;\n  }\n  return useMutation(mutationOptions);\n}","/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var e=require(\"react\");function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}\nfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n"],"names":["isServer","window","noop","parseQueryArgs","arg1","arg2","arg3","isQueryKey","_objectSpread","queryKey","queryFn","parseFilterArgs","matchQuery","filters","query","_filters$type","type","exact","fetchStatus","predicate","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","fetching","mutationKey","hashQueryKey","status","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","partialDeepEqual","some","replaceEqualDeep","array","isPlainArray","aSize","length","bItems","bSize","copy","equalItems","i","value","Array","isArray","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","toString","call","sleep","timeout","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","replaceData","prevData","data","isDataEqual","structuralSharing","_get","Reflect","get","bind","target","property","receiver","base","object","getPrototypeOf","desc","getOwnPropertyDescriptor","arguments","apply","this","defaultLogger","console","notifyManager","queue","transactions","notifyFn","batchNotifyFn","schedule","push","flush","originalQueue","forEach","batch","batchCalls","_len","args","_key","setNotifyFunction","fn","setBatchNotifyFunction","createNotifyManager","Subscribable","_classCallCheck","listeners","subscribe","_createClass","listener","_this","onSubscribe","filter","x","onUnsubscribe","focusManager","_Subscribable","_inherits","FocusManager","_super","_createSuper","setup","onFocus","addEventListener","removeEventListener","cleanup","setEventListener","_this$cleanup","hasListeners","undefined","_this$cleanup2","_this2","focused","setFocused","document","includes","visibilityState","onlineManager","OnlineManager","onOnline","online","setOnline","navigator","onLine","defaultRetryDelay","failureCount","Math","min","pow","canFetch","networkMode","isOnline","CancelledError","revert","silent","isCancelledError","createRetryer","config","continueFn","promiseResolve","promiseReject","isRetryCancelled","isResolved","promise","outerResolve","outerReject","shouldPause","isFocused","onSuccess","reject","onError","pause","continueResolve","canContinue","onPause","onContinue","run","promiseOrValue","error","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","cancel","cancelOptions","abort","continue","cancelRetry","continueRetry","Removable","clearGcTimeout","cacheTime","Infinity","gcTimeout","optionalRemove","newCacheTime","max","clearTimeout","Query","_Removable","abortSignalConsumed","defaultOptions","setOptions","observers","cache","logger","initialState","initialData","hasData","initialDataUpdatedAt","dataUpdateCount","dataUpdatedAt","Date","now","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchFailureReason","fetchMeta","isInvalidated","getDefaultState","scheduleGc","meta","updateCacheTime","remove","newData","dispatch","updatedAt","manual","setStateOptions","_this$retryer","retryer","_getPrototypeOf","destroy","setState","observer","enabled","getObserversCount","getCurrentResult","staleTime","timeUntilStale","_this$retryer2","find","shouldFetchOnWindowFocus","refetch","cancelRefetch","_this$retryer3","shouldFetchOnReconnect","indexOf","notify","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","abortController","AbortController","getAbortController","queryFnContext","pageParam","addSignalProperty","defineProperty","enumerable","signal","_context$fetchOptions2","context","fetchFn","behavior","onFetch","revertState","_this$cache$config$on","_this$cache$config","_this$cache$config$on2","_this$cache$config2","onSettled","isFetchingOptimistic","_this$cache$config$on3","_this$cache$config3","_this$cache$config$on4","_this$cache$config4","setData","Error","action","_this3","_action$meta","_action$dataUpdatedAt","reducer","onQueryUpdate","QueryCache","queries","queriesMap","client","_options$queryHash","getLogger","defaultQueryOptions","getQueryDefaults","add","queryInMap","_parseFilterArgs","_slicedToArray","_parseFilterArgs3","event","_this4","_this5","Mutation","mutationId","mutationCache","_this$retryer$continu","execute","_execute","_asyncToGenerator","_regeneratorRuntime","mark","_callee","executeMutation","restored","_this$mutationCache$c3","_this$mutationCache$c4","_this$options$onSucce","_this$options2","_this$mutationCache$c5","_this$mutationCache$c6","_this$options$onSettl","_this$options3","_this$mutationCache$c","_this$mutationCache$c2","_this$options$onMutat","_this$options","_this$mutationCache$c7","_this$mutationCache$c8","_this$options$onError","_this$options4","_this$mutationCache$c9","_this$mutationCache$c10","_this$options$onSettl2","_this$options5","wrap","_context","prev","next","_this$options$retry","mutationFn","variables","onMutate","sent","abrupt","t0","finish","stop","failureReason","isPaused","onMutationUpdate","MutationCache","mutations","defaultMutationOptions","getMutationDefaults","_this$resuming","resuming","pausedMutations","infiniteQueryBehavior","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","cancelled","buildNewPages","param","page","previous","concat","_toConsumableArray","fetchPage","_context$signal","_context$signal2","aborted","queryFnResult","getNextPageParam","getPreviousPageParam","shouldFetchFirstPage","_loop","QueryClient","queryCache","queryDefaults","mutationDefaults","mountCount","unsubscribeFocus","resumePausedMutations","unsubscribeOnline","_this$unsubscribeFocu","_this$unsubscribeOnli","findAll","_this$queryCache$find","parsedOptions","cachedData","getQueryData","fetchQuery","queryKeyOrFilters","getQueryCache","map","_ref2","updater","input","functionalUpdate","defaultedOptions","build","_ref3","setQueryData","_this$queryCache$find2","_parseFilterArgs5","_parseFilterArgs6","refetchFilters","reset","refetchQueries","_parseFilterArgs7","_parseFilterArgs8","_parseFilterArgs8$","promises","all","_parseFilterArgs9","_parseFilterArgs10","_ref","_filters$refetchType","invalidate","refetchType","_this6","_parseFilterArgs11","_parseFilterArgs12","isDisabled","_options$cancelRefetc","fetch","throwOnError","isStaleByTime","fetchInfiniteQuery","firstMatchingDefaults","_defaulted","refetchOnReconnect","useErrorBoundary","suspense","clear","useSyncExternalStore","useSyncExternalStore$1","MutationObserver","bindMethods","updateResult","mutate","_this$currentMutation","prevOptions","shallowEqualObjects","getMutationCache","currentMutation","_this$currentMutation2","removeObserver","notifyOptions","currentResult","mutateOptions","addObserver","isLoading","isSuccess","isError","isIdle","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","defaultContext","React","QueryClientSharingContext","getQueryClientContext","contextSharing","ReactQueryClientContext","useQueryClient","queryClient","QueryClientProvider","_ref2$contextSharing","mount","unmount","Context","useMutation","_React$useState","_useErrorBoundary","params","onStoreChange","_excluded","url","_temp","_ref$contentType","contentType","fetchOption","_objectWithoutPropertiesLoose","option","headers","_extends","Accept","Headers","token","sessionStorage","getItem","localStorage","set","getFetchOption","res","test","String","Response","statusText","json","err","message","_excluded2","refetchOnWindowFocus","useReactMutation","credentials","integrity","keepalive","_ref2$method","method","mode","redirect","referrer","referrerPolicy","_ref2$contentType","_ref2$headerTokenName","headerTokenName","opts","mutationOptions","body","slice","e","require","k","is","l","useState","m","useEffect","n","useLayoutEffect","p","useDebugValue","r","getSnapshot","d","f","u","createElement","inst","c","g","exports","module"],"sourceRoot":""}